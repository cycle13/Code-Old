---
layout:     post
title:      "Python 位操作"
subtitle:   "Python bitwise operation"
date:       2017-10-14
author:     "QQF"
header-img: "img/home-bg.png"
catalog: true
tags:
    - Python
---

# 什么是位操作

计算机中的数字都是用二进制形式表示的，在python里面，给数字加上前缀 '0b' 表示是二进制数字，如下示例，左边是二进制，右边是

```
0b1 => 1
0b10 => 2
0b1111 => 15
```

类似的，python当中的十六进制和八进制数字的前缀分别为 '0x' 和 '0'，下面的例子中右边是十进制

```
# 十六进制
0x10 => 16
0xff => 255
# 八进制
010 => 8
017 => 15
```

二进制数字有自己的特殊运算，是对每一位数字分别进行的操作，所以叫做位操作，Python共有以下几种位操作符：

```
x >> y # 返回 x 向右移 y 位得到的结果
x << y # 返回 x 向左移 y 位得到的结果
x & y # 且操作，返回结果的每一位是 x 和 y 中对应位做 and 运算的结果，只有 1 and 1 = 1，其他情况位0
x | y # 或操作，返回结果的每一位是 x 和 y 中对应位做 or 运算的结果，只有 0 or 0 = 0，其他情况位1
~x # 反转操作，对 x 求的每一位求补，只需记住结果是 -x - 1
x ^ y # 或非运算，如果 y 对应位是0，那么结果位取 x 的对应位，如果 y 对应位是1，取 x 对应位的补
```

# 位操作详解

## 左移和右移操作

顾名思义，左移和右移的意思就是把位数整体向左或者向右移动若干位。比如1111向右移一位就变成了0111，原来没有的位自动填0，超出范围的位舍弃掉。下面再看几个例子：

```
0b1111 >> 1 = 0b111 = 7
0b1010 << 2 = 0b101000 = 40
0b111111 >> 3 = 0b111 = 7
0b1 << 4 = 0b10000 = 16
```

向右移1位可以看成除以2，向左移一位可以看成乘以2。移动n位可以看成乘以或者除以2的n次方。

```
8 >> 2 <=> 8 / 2 / 2 <=> 0b1000 >> 2 = 0b10 = 2
8 << 2 <=> 8 * 2 * 2 <=> 0b1000 << 2 = 0b100000 = 32 
```

## 且操作 &

对于单个位的且操作

1 & 1 = 1

1 & 0 = 0 & 1 = 0 & 0 = 0

两个数字的且操作就是对每一位进行且操作取结果

```
0b1 & 0b0 = 0
0b1111 & 0b1010 = 0b1010 = 10
0b1010 & 0b1100 = 0b1000 = 8
```

## 或操作 |

对于单个位的或操作

1 | 0 = 0 | 1 = 1 | 1 = 1

0 | 0 = 0

两个数字的或操作就是对每一位进行或操作取结果

```
0b1 | 0b0 = 0b1 =1
0b1000 | 0b0111 = 0b1111 = 15
0b1010 | 0b1100 = 0b1110 = 14
```

## 反转操作 ~

python的反转操作只接受一个参数n，n必须是整数，效果是对n的内部表示的每一位求补，运算结果位 -n-1

```
~8 = -9
```

一些同学可能会疑惑，~8不应该是 ~0b1000 = 0b0001 = 1 才对吗。事情是这样的，计算机在内部表示负整数的时候用的是正数的补，比如 0b0001 是1，它的补是 0b1110，这个时候0b1110 在计算机内部不是7，而是-1。 这样一来，可以推导出来~n的结果是 -n-1 。不过你自己写的0b1111在这个语境下并不是一个负数，所以结果仍是15。

## 或非操作 ^

对于 x ^ y，如果y的位是0，那么取x的原始值，如果y的位是1，那么取x此位的补，例如

```
0b1111 ^ 0b0101 = 0b1010
0b1111 ^ 0b1 = 0b1110 # 自动填0
```
